@startuml
title
MOR.1 Dokonaj rezerwacji.
end title

autoactivate on
participant ReservationEndpoint
participant AlleyEndpoint
participant WeaponModelEndpoint
participant "ReservationManager\nTransactionAttribute.REQUIRES_NEW" as ReservationManager
participant "AlleyManager\nTransactionAttribute.REQUIRES_NEW" as AlleyManager
participant "WeaponModelManager\nTransactionAttribute.REQUIRES_NEW" as WeaponModelManager
control "ReservationFacadeReadCommitted\nTransactionAttribute.MANDATORY" as ReservationFacadeReadCommitted
control "WeaponModelFacadeReadCommitted\nTransactionAttribute.MANDATORY" as WeaponModelFacadeReadCommitted
control "AlleyFacadeReadCommitted\nTransactionAttribute.MANDATORY" as AlleyFacadeReadCommitted
control "CustomerFacadeSerializable\nTransactionAttribute.MANDATORY" as CustomerFacadeSerializable
control "ReservationFacadeSerializable\nTransactionAttribute.MANDATORY" as ReservationFacadeSerializable
control "WeaponModelFacadeSerializable\nTransactionAttribute.MANDATORY" as WeaponModelFacadeSerializable
entity ReservationEntity
entity AlleyEntity
entity WeaponModelEntity
entity WeaponModelEntity

alt
autonumber
     AlleyEndpoint -> AlleyManager: getAllActiveAlleys()
           AlleyManager -> AlleyFacadeReadCommitted: findByActive(true)
             return list of all active alleys
    return list of all active alleys
    note right of ReservationEndpoint
    [...]
    end note
    WeaponModelEndpoint -> WeaponModelManager: getAllActiveWeaponModelsWithActiveWeapons()
         WeaponModelManager -> WeaponModelFacadeReadCommitted: findByActive(true)
             return list of all active weapon models
     return list of all active weapon models
    note right of ReservationEndpoint
    [...]
    end note
     ReservationEndpoint -> ReservationManager: getConflictReservationsByWeaponModel(date, alleyName, weaponModelName, excludedReservationNumber)
        ReservationManager -> ReservationFacadeReadCommitted: findConflictedReservationByWeaponModel(startDate, endDate, weaponModelName, alleyName)
         return list of conflicted reservations
     return list of conflicted reservations
    alt correct
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return optional with customer
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return optional with weapon model
        ReservationManager -> WeaponModelEntity: isActive()
        return true
        ReservationManager -> ReservationManager: checkReservationDuration(startDate, endDate)
        return success
        ReservationManager -> ReservationManager: checkOpeningHours(startDate, endDate)
         return success
         ReservationManager -> ReservationFacadeSerializable: findConflictReservationsByWeaponModel(startDate, endDate, weaponModelName, alleyName)
         return list of conflict reservations
         ReservationManager -> ReservationManager: checkIfAlleyIsAvailable(conflictedReservations, alleyEntity)
         return success
         ReservationManager -> ReservationManager: getActiveWeaponByWeaponModel(conflictedReservation, weaponModelEntity)
         return weapon to reserve
         ReservationManager -> ReservationManager: addReservation(reservationEntity, customerEntity, alleyEntity, weaponToReserve)
            ReservationManager -> ReservationEntity: setActive(true)
            return success
            ReservationManager -> ReservationEntity: setAlley(alleyEntity)
            return success
            ReservationManager -> ReservationEntity: setWeapon(weaponToReserve)
            return success
            ReservationManager -> ReservationEntity: setCustomer(customerEntity)
            return success
            ReservationManager -> WeaponEntity: getReservation()
            return list of reservations
            ReservationManager -> List: add(reservationEntity)
            return success
            ReservationManager -> AlleyEntity: getReservation()
            return list of reservations
            ReservationManager -> List: add(reservationEntity)
            return success
            ReservationManager -> ReservationFacadeSerializable: create(alleyEntity)
            return success
         return success
         ReservationManager -> CustomerEntity: getEmail()
         return email of customer
         ReservationManager -> ReservationEntity: getReservationNumber()
         return reservation number
         ReservationManager -> EmailCreator: getMakeReservationEmail(language, customerEmail, reservationNumber)
         return make reservation email
         ReservationManager -> EmailSender: sendEmail(makeReservationEmail)
         return success
        return success
    else customer does not exist
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
    return customer does not exist
    else alley does not exist
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley does not exist
    return alley does not exist
    else alley is already deactivated
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley is already deactivated
    return alley is already deactivated
    else weapon model does not exist
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return empty optional
    return weapon model does not exist
    else weapon model is not active
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return weapon to reserve
        ReservationManager -> WeaponModelEntity: isActive()
        return false
    return weapon model is not active
    else Reservation is too long
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return weapon to reserve
        ReservationManager -> WeaponModelEntity: isActive()
        return true
        ReservationManager -> ReservationManager: checkReservationDuration(startDate, endDate)
        return reservation is too long
    return reservation is too long
    else Reservation during closing hours
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return weapon to reserve
        ReservationManager -> WeaponModelEntity: isActive()
        return true
        ReservationManager -> ReservationManager: checkReservationDuration(startDate, endDate)
        return success
        ReservationManager -> ReservationManager: checkOpeningHours(startDate, endDate)
        return reservation during closing hours
    return reservation during closing hours
    else Alley is not available
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return weapon to reserve
        ReservationManager -> WeaponModelEntity: isActive()
        return true
        ReservationManager -> ReservationManager: checkReservationDuration(startDate, endDate)
        return success
        ReservationManager -> ReservationManager: checkOpeningHours(startDate, endDate)
        return success
        ReservationManager -> ReservationFacadeSerializable: findConflictReservationsByWeaponModel(startDate, endDate, weaponModelName, alleyName)
        return list of conflict reservations
        ReservationManager -> ReservationManager: checkIfAlleyIsAvailable(conflictedReservations, alleyEntity)
        return alley is not available
    return alley is not available
    else Weapon model is not available
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return weapon to reserve
        ReservationManager -> WeaponModelEntity: isActive()
        return true
        ReservationManager -> ReservationManager: checkReservationDuration(startDate, endDate)
        return success
        ReservationManager -> ReservationManager: checkOpeningHours(startDate, endDate)
        return success
        ReservationManager -> ReservationFacadeSerializable: findConflictReservationsByWeaponModel(startDate, endDate, weaponModelName, alleyName)
        return list of conflict reservations
        ReservationManager -> ReservationManager: checkIfAlleyIsAvailable(conflictedReservations, alleyEntity)
        return success
        ReservationManager -> ReservationManager: getActiveWeaponByWeaponModel(conflictedReservation, weaponModelEntity)
        return weapon model is not available
    return weapon model is not available
    else Error when sending an email
    autonumber
    note right of ReservationEndpoint
    [...]
    end note
    ReservationEndpoint -> ReservationManager: makeReservation(reservationEntity, alleyName, weaponModelName, language)
        ReservationManager -> SecurityContext: getCallerPrincipal()
        return principal
        ReservationManager -> CustomerFacadeSerializable: findByLogin(login)
        return customer does not exist
        ReservationManager -> ReservationManager: getActiveAlleyByName(alleyName)
        return alley
        ReservationManager -> WeaponModelFacadeSerializable: findByName(weaponModelName)
        return weapon to reserve
        ReservationManager -> WeaponModelEntity: isActive()
        return true
        ReservationManager -> ReservationManager: checkReservationDuration(startDate, endDate)
        return success
        ReservationManager -> ReservationManager: checkOpeningHours(startDate, endDate)
        return success
        ReservationManager -> ReservationFacadeSerializable: findConflictReservationsByWeaponModel(startDate, endDate, weaponModelName, alleyName)
        return list of conflict reservations
        ReservationManager -> ReservationManager: checkIfAlleyIsAvailable(conflictedReservations, alleyEntity)
        return success
        ReservationManager -> ReservationManager: getActiveWeaponByWeaponModel(conflictedReservation, weaponModelEntity)
        return weapon to reserve
        ReservationManager -> ReservationManager: addReservation(reservationEntity, customerEntity, alleyEntity, weaponToReserve)
            ReservationManager -> ReservationEntity: setActive(true)
            return success
            ReservationManager -> ReservationEntity: setAlley(alleyEntity)
            return success
            ReservationManager -> ReservationEntity: setWeapon(weaponToReserve)
            return success
            ReservationManager -> ReservationEntity: setCustomer(customerEntity)
            return success
            ReservationManager -> WeaponEntity: getReservation()
            return list of reservations
            ReservationManager -> List: add(reservationEntity)
            return success
            ReservationManager -> AlleyEntity: getReservation()
            return list of reservations
            ReservationManager -> List: add(reservationEntity)
            return success
            ReservationManager -> ReservationFacadeSerializable: create(alleyEntity)
            return success
        return success
        ReservationManager -> CustomerEntity: getEmail()
        return email of customer
        ReservationManager -> ReservationEntity: getReservationNumber()
        return reservation number
        ReservationManager -> EmailCreator: getMakeReservationEmail(language, customerEmail, reservationNumber)
        return make reservation email
        ReservationManager -> EmailSender: sendEmail(makeReservationEmail)
        return error when sending an email
    return error when sending an email
    end
else no available alleys
autonumber
AlleyEndpoint -> AlleyManager: getAllActiveAlleys()
      AlleyManager -> AlleyFacadeReadCommitted: findByActive()
      return empty list
return empty list
note right of ReservationEndpoint
[...]
end note
WeaponModelEndpoint -> WeaponModelManager: getAllActiveWeaponModelsWithActiveWeapons()
   WeaponModelManager -> WeaponModelFacadeReadCommitted: findByActive()
   return list of all active weapon models
return list of all active weapon models
else no available weapon models
autonumber
AlleyEndpoint -> AlleyManager: getAllActiveAlleys()
      AlleyManager -> AlleyFacadeReadCommitted: findByActive()
      return list of all active alleys
return list of all active alleys
note right of ReservationEndpoint
[...]
end note
WeaponModelEndpoint -> WeaponModelManager: getAllActiveWeaponModels()
   WeaponModelManager -> WeaponModelFacadeReadCommitted: findByActive()
   return empty list
return empty list
end
@endumla
